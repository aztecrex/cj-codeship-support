# functions for signaling between containers

# standard rd conventions apply:
#  - symbol beginning with underscore is not part of public interface
#  - symbol dependencies flow in the direction of >= underscore count
#  - private symbols include this package name ("cjbashsig") in their names
#  - this is subshell friendly. state is stored in a temporary file

# Uses environment variable FEATURE_DATA_DIR to choose its store directory.
# If not set, it uses the TMPDIR value to choose the store directory.
# Otherwise, uses the /tmp direcory.

if [ $BASH_VERSINFO -lt 4 ]; then
  echo "Bash 4.0 or greater required" >&2
  [[ $- == *i* ]] || exit -2
  return -2
fi

__cjbashsig_data_dir=$(cd "${FEATURE_DATA_DIR-${TMPDIR-/tmp}}" && pwd)
mkdir -p "$__cjbashsig_data_dir"
declare -x __cjbashsig_data_f="${__cjbashsig_data_dir}/cjbashsig.data"

_cjbashsig_with_data() {
  if [ ! -s "$__cjbashsig_data_f" ]; then
    declare -Ax signals=()
  else
    source "$__cjbashsig_data_f"
  fi

  "$@"
  local ret=$?

  declare -p signals > "$__cjbashsig_data_f"
  unset signals

  return $ret
}

_cjbashsig_clear() {
  unset signals[$1]
  return 0
}

_cjbashsig_set() {
  signals[$1]="$2"
  return 0
}

_cjbashsig_have() {
  eval '[ ${signals['$1']+x} ]'
}

_cjbashsig_get() {
  if _cjbashsig_have "$1"; then
    echo -n "${signals[$1]}"
    return 0
  else
    return 1
  fi
}

# signal operations:
#  signal <name>                  # set signal to default value
#  signal <name> with <value>     # set signal to specific value
#  signal <name> present          # zero status if present
#  signal <name> value            # echo signal value, zero status if present
signal() {
  local cmd=${2-}
  case $cmd in
    present)
      _cjbashsig_with_data _cjbashsig_have "$1"
      return $?
      ;;
    with)
      _cjbashsig_with_data _cjbashsig_set "$1" "$3"
      return $?
      ;;
    value)
      _cjbashsig_with_data _cjbashsig_get "$1"
      return $?
      ;;
    '')
      _cjbashsig_with_data _cjbashsig_set "$1" signaled
      ;;
    *)
      echo 'unrecognized command' >&2
      return -1
      ;;
  esac
}

# signal operations
#   unsiginal <name>              # clear a signal
unsignal() {
  _cjbashsig_with_data _cjbashsig_clear "$1"
}

# clean up allocated resources. removes all signal data
close_signals() {
  rm -f "$__cjbashsig_data_f"
}
